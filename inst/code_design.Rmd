---
title: "Code Design"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Code Design}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(DiagrammeR)
```

It's nice to know how the code works. Let's keep a diary of sorts as we work on this.

Within the simulation loop, we'll want to have process functions for each stage where individuals can become vaccinated. It might look like this:

```
while (run sim)
    vaccination_process()
    infection_process()
    events()
    updates()
end
```

Most of the simulation updates state by TargetedEvents. When a targeted event fires, there are 2 types of listeners that would normally be called.

  1. schedulers - these are functions like `create_event_scheduler_listener` which schedule future events (`create_progression_listener` in original code).
  2. state updates - these are functions like `create_state_update_listener` which update state when the event fires (`create_infection_update_listener` in original code).

There could be others, to update tracking variables for example, but only these two types are necessary for the model dynamics.

## Vaccination (multiple dosing model)

Now that **nimue** has an approximation of multiple dosing strategies based on weighting the time varying efficacy let's see how to do this in **safir**.

There's some functions in weighted_efficacy.R we should be familiar with:

* `assign_doses`: this function is simple, given an integer number of doses and a vector of eligible populations (by age), distributes the doses. If num doses > sum(target_pop), everyone gets one. If not, assign doses weighted proportionally to population size.

* `coverage`: this function takes a data structure (`dose_times`) that is a list of length `N_age` and in each element is a matrix of dims (`N_pop_age` (size of age group) X `N_doses`). So if age group 1 had 5 people and this vaccine had 2 doses, it would be a 5x2 matrix. If a person hasn't recieved that dose yet, the element of the matrix is `NA`. If they have, the time it was given is the integer day. `coverage` then computes the coverage % for each age for the user input `dose_number`. So the output is a vector of length equal to the list length `N_age`. The **safir** equivalent is `get_proportion_vaccinated` and `get_proportion_vaccinated_type`.

* `eligable_for_second`: this function takes the same data structure (`dose_times`) as `coverage`. It returns a list of length `N_age` of vectors of length equal to `N_pop_age`. Each element says if this person is eligible for 2nd dose. It checks for each person if `t - first_dose_time >= dose_period` (where `dose_period` is days between dose 1 and dose 2), and that person has not already had their second dose.

* `administer_first_dose`: this simple function takes in a vector of doses by age group, and the `dose_times` data structure. It updates `dose_times` (`NA` values become current `t`)

* `administer_second_dose`: same as `administer_first_dose` but uses `eligable_for_second` to check if those people are eligible before administration.

* `target_pop`: this function finds the number of individuals in each age group to vaccinate for a given dose `dose_number`.
  ```{r}
  suppressPackageStartupMessages(library(nimue))
  dose_times <- list(matrix(c(1, 2, NA, NA, 3, NA), nrow = 3),
               matrix(c(NA, NA, NA, NA, 3, 4), nrow = 3),
               matrix(c(1, 2, 2, NA, NA, NA), nrow = 3))
  prioritisation = rep(1, 3)
  dose_number = 1
  t = 15
  dose_period = 14
  d2_prioritise = rep(FALSE, 3)
  nimue:::target_pop(dose_number = dose_number,dose_times = dose_times,prioritisation = prioritisation,t = t,dose_period = dose_period,d2_prioritise =     d2_prioritise)
  ```
The way it works is like this:
  
1. the code computes `current_coverage <- coverage(dose_times, dose_number)`
2. `n_to_cover <- ceiling(pmax(0, (prioritisation - current_coverage)) * sapply(dose_times, nrow))` this first computes the fraction remaining to vaccinate `pmax(0, (prioritisation - current_coverage))`, which may be zero if that age group is not in the current row of the prioritization matrix. Then multiplying by the number of people in each age group and taking ceiling gives the number who are eligible for vaccination by age group.
3.  if this is for second dose, there's some more logic. `eligable <- sapply(eligable_for_second(dose_times, t, dose_period), sum)` gives the number of people in each age group who are eligible for 2nd dose (past the `dose_period`). Then `n_to_cover <- pmin(n_to_cover, eligable) * d2_prioritise` gets the final number who may be vaccinated, which is the minimum of this value, and `n_to_cover`, which was computed without regard to time. Finally multiply by the `d2_prioritise` for age groups being prioritized (or not).

So those are the individual functions. They all get wrapped up in the big one, `weighted_efficacy` which actually runs the vaccine distribution "simulation". This one has four steps:

  1 . Give doses to any age groups where dose1 coverage < current prioritisation coverage (https://github.com/mrc-ide/nimue/blob/5c812a1cf539676ccd994a75a2f7e76499642984/R/weighted_efficacy.R#L208-L214)
  
  2. Give any remaining doses as 2nd doses where dose2 coverage < current prioritisation coverage AND age group is prioritised for dose 2 (https://github.com/mrc-ide/nimue/blob/5c812a1cf539676ccd994a75a2f7e76499642984/R/weighted_efficacy.R#L216-L225)
  
  3. For efficient dose use, step through prioritisation matrix an give any remaing doses out as dose 1 (https://github.com/mrc-ide/nimue/blob/5c812a1cf539676ccd994a75a2f7e76499642984/R/weighted_efficacy.R#L228-L242)
  
  4. When all of dose1 coverages are >= the final step of the prioritisation matrix AND all of dose 2 coverages for age groups prioritised for 2nd dose >= the final step of the prioritisation matrix, we "reset" the prioritisation matrix to the first row and step through ensuring all remaining dose2 coverage > current prioritisation coverage (https://github.com/mrc-ide/nimue/blob/5c812a1cf539676ccd994a75a2f7e76499642984/R/weighted_efficacy.R#L260-L268)

We just need to replicate this at each step in **safir**. The big remaining question is just how `infection_efficacy` and `disease_efficacy` work in **safir**.

### **safir** implementation

#### *nimue*
In **nimue**, phase 2 is reached when dose 1 coverage >= final step of prioritization matrix and dose 2 coverage for groups prioritized for dose 2 >= final step of prioritization matrix.

#### **safir**
In **safir** we will have arbitrarily many doses. How do we do this same thing when `N_dose = 2` but also generalize to the general case? We track what dose we are giving out by the variable `phase`.

Within each value of `phase` (for now, arbitrarily assume `phase = 1`), we need to give out doses according to the prioritization matrix. On a step:
  
  1. find out what step of `vaccine_coverage_mat` we are on using existing code, distribute `phase` doses to age groups in that step whose coverage < that step's prioritization coverage
  2. give out remaining doses as `phase + 1` doses to age groups in this step who are eligible *and* are prioritized based on `vaxx_priority[phase, ]`.
  3. if doses still remain, assign `phase` doses to individuals based on going through the rest of the `vaccine_coverage_mat`
  4. if we are at the final stage of prioritization and all `phase` dose coverage is fulfilled, and `phase + 1` coverage fulfilled for `vaxx_priority[phase, ]` age groups, set `phase = phase + 1` and advance.
  
The only slight modification is what goes on during the final phase. In this case the algorithm is much simpler. It just gives out final doses for everyone until the coverage targets are hit. If for whatever reason the maximum phase is 1, then treat the initial phase as the maximum phase.

  1. find out what step of `vaccine_coverage_mat` we are on using existing code, distribute `phase` doses to age groups in that step whose coverage < that step's prioritization coverage.
  2. if doses still remain, assign `phase` doses to individuals based on going through the rest of the `vaccine_coverage_mat`
  
#### target and assign/distribute

Given the current `phase` (what dose we are distributing), `prioritization` (the step of prioritization strategy), and `vaxx_priority` (an optional priority )

Squares are input parameters, circles are functions. `target_pop` gives us how we'd like to assign vaccines, and the external input `doses` constrains it.

```{r,echo=FALSE}
nodefontsize <- 6
edgefontsize <- 5

graph <-
  create_graph() %>%
  add_node(label = "phase",node_aes = node_aes(shape = "plaintext", fontsize = nodefontsize)) %>%
  add_node(label = "prioritization",node_aes = node_aes(shape = "plaintext", fontsize = nodefontsize)) %>%
  add_node(label = "vaxx_priority",node_aes = node_aes(shape = "plaintext", fontsize = nodefontsize)) %>%
  add_node(label = "target_pop",node_aes=node_aes(fontsize = nodefontsize)) %>%
  add_node(label = "eligible_ages_bset",node_aes = node_aes(shape = "plaintext", fontsize = nodefontsize)) %>%
  add_node(label = "eligible_ages_counts",node_aes = node_aes(shape = "plaintext", fontsize = nodefontsize)) %>%
  add_node(label = "n_to_cover",node_aes = node_aes(shape = "plaintext", fontsize = nodefontsize)) %>%
  add_node(label = "doses",node_aes = node_aes(shape = "plaintext", fontsize = nodefontsize)) %>%
  add_node(label = "assign_doses",node_aes=node_aes(fontsize = nodefontsize))

graph <-
  graph %>%
  set_node_position( # phase
    node = 1,
    x = 0, y = 3) %>%
  set_node_position( # priority
    node = 2,
    x = 1, y = 3) %>%
  set_node_position( #vaxx_priority
    node = 3,
    x = 2, y = 3) %>%
  set_node_position( # target_pop
    node = 4,
    x = 1, y = 2) %>%
  set_node_position( # eligible_ages_bset
    node = 5,
    x = 0, y = 1) %>%
  set_node_position( # eligible_ages_counts
    node = 6,
    x = 1, y = 1) %>%
  set_node_position( # n_to_cover
    node = 7,
    x = 2, y = 1) %>%
  set_node_position( # doses
    node = 8,
    x = 3, y = 1) %>%
  set_node_position( # assign_doses
    node = 9,
    x = 1, y = 0) 

graph <- 
  graph %>%
  add_edge(from = 1, to = 4) %>%
  add_edge(from = 2, to = 4) %>%
  add_edge(from = 3, to = 4) %>%
  add_edge(from = 4, to = 5) %>%
  add_edge(from = 4, to = 6) %>%
  add_edge(from = 4, to = 7) %>%
  add_edge(from = 5, to = 9) %>%
  add_edge(from = 6, to = 9) %>%
  add_edge(from = 7, to = 9) %>%
  add_edge(from = 8, to = 9)

render_graph(graph, layout = "neato",width = 600,height = 500)
```

### Parameters needed

We need new parameters in the list of named parameters.

  * `N_dose`: number of doses. Can be a scalar or a vector (by num types).
  * `N_type`: number of types of vaccines
  * `N_phase`: number of phases (max of doses?)
  * `vaxx_types`: character vector of type names
  * `vaxx_priority`: a matrix, `N_dose - 1` by `N_age` (so if `N_dose` is 1, this is set to `NULL`). This matrix goes from 1,...,`N_dose - 1` and tells us, on this phase, what age group should get prioritized for the next dose.
  * `dose_period`: a vector of length `1:N_dose`. `dose_period[i]` gives how long one must wait after `i-1`-th dose to get the `i`-th dose. The first element is unused, but must be present.
  
We need a new variable to be in the list `variables`

  * `phase`: an integer in `1:N_dose`, telling us what phase we are on. The phase advances to `phase + 1` when for the current phase, all current dose coverage >= final step of prioritization matrix *and* next dose coverage for prioritized groups >= final step of prioritization matrix.

## Vaccination

### State representation

A straightforward way to track vaccines is this. Let `max_vaxx` be the maximum number of doses people will receive (assumed to be 2). For each dose two pieces of information must be stored, the time it was given and the type (for mixed dosing regimens).

  1. `IntegerVariable[max_vaxx]`: stores the time each dose is given.
  2. `CategoricalVariable[max_vaxx]`: store the type of vaccine for each dose.
  
One thing is that, if all we care about is people getting 1st v. 2nd doses of **anything**, we can just do the checks for coverage for any dose, and then give people doses based on what's available at that time. Or if someone gets a certain 1st dose, they are guaranteed to get subsequent doses of that type. Something like that.
  
### Transitions & scheduling

The `vaccination_process()` function should be the first one run in the daily simulation loop. It gets the number of vaccines available at this time step, and based on the prioritization scheme, figure out who is "at risk" of getting vaccinated; e.g. has a non-zero hazard of that event firing. Perhaps that can be returned as a bitset? Then for those people who are at risk of both, we do the multinomial sample for state updates, for those who are only at risk of infection (probably nobody only "at risk" of vaccination?) we do the normal binomial draw.

In [nimue](https://github.com/mrc-ide/nimue/blob/79d94720196420486a5995662fba5ff2f676e777/inst/odin/vaccine.R#L404) the code that handles how vaccines are allocated works like below:

```{r,eval=FALSE}
vr_temp[] <- S[i,1] * vaccination_target[i] + E1[i,1] * vaccination_target[i] + E2[i,1] * vaccination_target[i] + R1[i,1] * vaccination_target[i] + R2[i,1] * vaccination_target[i]
dim(vr_temp) <- N_age
# Catch so vaccination rate does not exceed 1 if the number of people available for vaccination < number of vaccines
vr_den <- if(sum(vr_temp) <= mv) mv else sum(vr_temp)
vr <- if(mv == 0) 0 else mv / vr_den  # Vaccination rate to achieve capacity given number in vaccine-eligible population
```

How it works:
  
  1. `mv` is interpolated from input, it's the maximum number of vaccines which can be given out in a day, so if there are more people to vaccinate than `mv`, it's the rate at which vaccines are distributed. If there are fewer people to vaccinate than `mv`, then the rate at which vaccines would be given out would be lower than `mv`.
  2. `vr_temp` is the total number of individuals in each age group (its dimension is `N_age`) who are eligible to get vaccines at that instant.
  3. `vr` will be `mv / vr_den` if there are more people to vaccinate than the maximum number of vaccines that can be given out that day then it's (`vr`) the proportion of those eligible who will get them. If there's fewer people to vaccinate than the maximum number of vaccines that can be given out that day then `vr` will be capped at 1.

It would make sense to calculate things in **safir** as closely as possible to this setup. How would this work in practice? `vaccine_process()` would have to do something like this:

  1. which age groups should be targeted for vaccination by using the targeting matrix; could be more or less the same as [nimue](https://github.com/mrc-ide/nimue/blob/79d94720196420486a5995662fba5ff2f676e777/inst/odin/vaccine.R#L393): 
      ```{r,eval=FALSE} 
      # Isolate age groups below current target coverage which must be targeted
      vaccination_target_mat[,] <- if(pr[j] < vaccine_coverage_mat[i,j]) 1 else 0
      ```
  2. for each age group that should be targeted get the number that haven't been vaccinated yet, in nimue it's simple
      ```{r,eval=FALSE}
      vr_temp[] <- S[i,1] * vaccination_target[i] + E1[i,1] * vaccination_target[i] + E2[i,1] * vaccination_target[i] + R1[i,1] * vaccination_target[i] + R2[i,1] * vaccination_target[i]
      dim(vr_temp) <- N_age
      ```
      In our case we'd want to do something likewise but with the state variables in eligible age groups. Lots of bitset and operations, return the sum.
  3. In the simple vaccination model now we can just get the bitset that is the union of *everyone* who is eligible from step 2, that's every single individual       who is eligible this time step.
  4. calculate the per-capita rate `vr` similarly, use this for those people given by the bitset in step 3 to do the draws for state transition.

This gives us a vaccination distribution module that looks like the one from **nimue**.

### Prioritization

One thing is that **nimue** doesn't think about how many doses a person was given. When they're vaccinated, they transition to the vaccinated compartment and that's it. We need to worry about that in **safir**.

Let's try to figure out what we're up against.

  * we have a mixed array of vaccines at our disposal, J&J and others only need 1 dose, Pfizer, Moderna, etc. need 2 doses.
  * the prioritization matrix doesn't know about doses.

How can we make sense of this? We have a few options. Here's one reasonable starting point.

  * For each vaccine type that has >1 dose, we have a priotiziation matrix for each dose (store as array for efficiency).
  * the prioritization step is shared between the 2 matrices, that is before we move to the next prioritization step, the targets in both (all) matrices need to be fulfilled.
  * we also need some sort of rule to figure out how many of the available daily doses each day should be apportioned to first vs. second dose individuals. One thing to do is to prioritize second dose individuals (which by definition would have already recieved a first dose previously) and allocate the leftover to newly arriving first dosers. this is probably closer to how it works in reality, as 2nd doses are more or less guaranteed whereas 1st doses can sometimes be acquired via "walk ups". The 2nd dose matrix should probably be interpreted as "of those who are eligible for 2nd dose, how many need to actually recieve them?"
  * for vaccines like J&J, just use the current single matrix setup.
  * each vaccine will have its own vector of availability each day.
  
That sounds good but there's some problems. The biggest one is this one, how do we figure out who will get vaccinated? What I mean is this, in **nimue**, because its an ODE model, the stochastic version would assume that S people (for example) are "at risk" of becoming infected *or* vaccinated with hazards equal to `lambda` and `vr`, respectively. To duplicate such behavior in **safir** is a bit of work, especially with respect to figuring out how to apportion the vaccination rate to different groups, and doses, etc. But the easier path, which would be to assign vaccine doses seperately, mean it would be posssible for someone to be both vaccinated and become infected on a time step, which is explicitly *not allowed* in **nimue** because the paths out of S(V0) are mutually exclusive. If we let both happen, we have a stochastic model that no longer will look like **nimue**.

If we put in the hard work, what are we left with?

  * on a time step, we can calculate `vr` normally, by summing everyone who is eligible (both for 1st and 2nd dose).
  * distribute the rate to 1st dosers vs. 2nd dosers based on some rule.
  * this is actually nicer for modeling hesistancy, because we could in theory do something like sample numbers with mean of 1 to model relative hesitancy/willingness.

So the question is, do we work with rates and have models that are self-consistent but harder to reason about, or do we work with integer number of vaccinations but end up with inconsistent models?

## **nimue** style vaccination

### Infection process `infection_process_nimue`

We'll go with a function that uses a calculated `vr` akin to the original **nimue** model but allows vaccination and infection to occur in a single time step. Normally, this would make a model that's pretty inconsistent with the stochastic interpretation of the deterministic model but I think in this case we got lucky. Here's why.

```{r,echo=F}
graph <-
  create_graph() %>%
  add_node(label = "S@_{0}") %>%
  add_node(label = "S@_{1}") %>%
  add_node(label = "E1@_{0}") %>%
  add_node(label = "E1@_{1}")

graph <-
  graph %>%
  set_node_position(
    node = 1,
    x = 0.5, y = 1) %>%
  set_node_position(
    node = 2,
    x = 2, y = 1) %>%
  set_node_position(
    node = 3,
    x = 0.5, y = 0) %>%
  set_node_position(
    node = 4,
    x = 2, y = 0)

edgefontsize <- 5

graph <- 
  graph %>%
  add_edge(from = 1, to = 2, edge_aes = edge_aes(label="vaccination",fontsize = edgefontsize)) %>%
  add_edge(from = 3, to = 4, edge_aes = edge_aes(label="vaccination",fontsize = edgefontsize)) %>%
  add_edge(from = 1, to = 3, edge_aes = edge_aes(label="infection (v0)",fontsize = edgefontsize)) %>%
  add_edge(from = 2, to = 4, edge_aes = edge_aes(label="infection (v1)",fontsize = edgefontsize)) %>%
  add_edge(from = 1, to = 4, edge_aes = edge_aes(label="infection+vaccinated",style="dashed",fontsize = edgefontsize))

render_graph(graph, layout = "neato",width = 600,height = 500)
```

Here's why this wont be a problem in this case. In the determinsitic model over an infintesimal time interval, only the solid line transitions are allowed. If we were interpreting the ODE model as the skeletion of a CTMC model, those would (still) be the only allowed transitions that could occur, were a single event to occur. Let's consider **safir** to be a discretization of the CTMC we wish we could run. Then, if the rates at which infection or vaccination occured differed depending on the state one was in, allowing two events to happen in one jump would be bad. Why? Because then the probability of the vaccination first, followed by infection in a time step != the probability of infection first, followed by vaccination in a time step. But because we assume vaccination's protective effect doesn't kick in until states V3,V4, the infection and the vaccination lines occur at the same rate. So order doesn't matter. It's still not going to make sense as $\Delta t \to 0$ but it will be a pretty good approximation.

Need to set up event progression for vaccines.

It looks like this right now

```{r,eval=F}
  events$v0_to_v1v2 = individual::TargetedEvent$new(N) # scheduled when vaccination occurs
  events$v1v2_to_v3v4 = individual::TargetedEvent$new(N) # scheduled when entering v1v2
  events$v3v4_to_v5 = individual::TargetedEvent$new(N) # scheduled when entering v3v4
```

```{r,echo=F}
graph <-
  create_graph() %>%
  add_node(label = "V0") %>% set_node_position(node=1,x=1,y=4) %>%
  add_node(label = "V1,V2") %>% set_node_position(node=2,x=1,y=3) %>%
  add_node(label = "V3,V4") %>% set_node_position(node=3,x=1,y=2) %>%
  add_node(label = "V5") %>% set_node_position(node=4,x=1,y=1) %>%
  add_edge(from = 1, to = 2, edge_aes = edge_aes(label="occurs at (S,E,R) vaccination")) %>%
  add_edge(from=2,to=3, edge_aes = edge_aes(label="event scheduled (gamma_vaccine_delay)")) %>%
  add_edge(from=3,to=4, edge_aes = edge_aes(label="event scheduled (gamma_V)"))

render_graph(graph, layout = "neato",width = 600,height = 500)
```

### Data structures

There are some new data structures stored in the list `variables`.

  * `vaccine_states`: a IntegerVariable where 1 = v0, 2 = v1,v2, 3 = v3,v4, 4 = v5. It's an integer variable and not categorical because we need to store integers for fast subsetting of probability vectors and matrices that depend on vaccine status (see `infection_process_nimue` for example).
  * `eligible`: a bitset of individuals who are eligible for vaccination, used in `vaccination_process_nimue`
  * `vaccinated`: gets set when someone goes from state 1 = v0 to 2 = v1,v2
  * `empty`: used to quickly empty the `eligible` bitset, see `vaccination_process_nimue`.

## Performance

To-do list:
  * optimize renderers for output, have something that can optionally only output daily.
